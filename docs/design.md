本文档是对addp工程的基本设计原则的说明。

addp：All Domain Data Platform，全域数据平台
基于Data Fabric思维、旨在支持所有类型数据进行汇聚、治理、计算、服务和资产管理等在内的数据平台。


# 总体设计原则
## 单一职责原则
各模块均有自己的职责，其他模块非必要，不得重复建设别的模块范围内的职责。
## 避免重复代码
当遇到类似代码实现时，应该在common等中实现，各模块再予以调用代码。
## 前端复用原则
每个模块都可以独立部署，按照微服务设计。
整个系统有统一的门户，统一门户集成各模块前端，避免重复实现，嵌入时主要不要出现内容重叠。注意采用system的统一认证，避免多次登录要求。
## 可扩展原则
通过插件等机制，支持数据类型可扩展，以实现对所有数据类型的支持；已经对各类数据存储和计算引擎的支持

模块划分
# system，系统管理
## 多租户和用户管理
用户类型分为：超级管理员、租户管理员和普通用户
超级管理员可创建和管理租户，租户采用租户id进行隔离，以后根据实际需要决定是否采用更加严格的隔离措施
租户管理员可创建和管理普通用户
普通用户无权创建其他用户
尚未进行项目组或工作组的划分，看以后需求再定

## 认证管理
所有模块的统一认证和登录，均由system管理，直接调用system完成。其他模块不得自行进行认证工作

## 资源管理
当前仅包括存储引擎（包括但不限于数据库、对象存储等）的链接设置和可用性测试。
后续会增加其他资源类型，如计算引擎（如spark、ray等）、私有容器库、私有代码库、硬件资源等的管理。
其他模块在访问资源时，均直接调用system的接口完成，各模块无需做缓存等，防止信息不同步
### 存储引擎
#### Postgresql（含postgis）
注册时，提供url、database、user和password
#### minio
注册时，提供url、bucket（可选），ak和sk


# 内置系统存储
所有模块，均采用一套内置的系统存储。当前已使用Postgresql数据库管理结构化数据，后续会根据实际需要增加redis、minio、elasticsearch等内置的系统存储能力。
## 内置系统数据库
内部根据各模块名字划分为不同schema，如system、meta等。
各schema，原则上只能由对应的模块予以写入。
对于读取，则要分情况处理：如用户管理、认证信息、资源管理中的密码等关键内容，只能由system模块进行；
其他内容，则各模块均可以根据需要予以直接读取，避免通过api访问带来的性能损耗。
如meta模块，可以直接读取system schema中资源管理中的条目，但要进行连接时，则必须通过system的接口来进行，因为链接的密码是做过加密的。
## todo 根据租户进行内置数据库的database隔离
当前是根据租户id进行隔离，如果要增强租户隔离错误，可以考虑用不同的database进行隔离。

# meta模块
meta模块负责所有元数据的统一存储、血缘追踪和基于元数据的检索。

## meta统一存储方式
对于数据库和对象存储，其数据组织方式是不同的：
- 数据库：实例 → database → schema → table（注册入口是 database）
- 对象存储：实例 → bucket → prefix（多级）→ object（注册入口是实例或 bucket）

为了统一管理与扩展，废弃旧版按类型拆分的 `meta_*` 表（如按 database、bucket、schema 划分的遗留表），统一使用以下三张核心表：

- `meta_resource`  
  - 描述注册入口，覆盖数据库实例中的某个 database 或对象存储的实例 / bucket。  
  - 关键字段：`id`、`resource_type`、`name`、`engine`、`config`（连接信息）、`status`、`source`（采集来源）、`sync_version`、`created_at`、`updated_at`、`deleted_at`。  
  - 统一维护软删字段 `deleted_at`，避免误删数据，并方便回滚。

- `meta_node`  
  - 表示资源下的层级节点，可递归指向自身，覆盖数据库的 schema、视图集合等，以及对象存储的 prefix。  
  - 关键字段：`id`、`res_id`、`parent_node_id`、`node_type`、`depth`、`path`（纯 ID 链路）、`full_name`（便于展示与查询）、`status`、`attributes`（可选元信息，JSON）。  
  - `node_type` 采用枚举字典表 `meta_node_type_dict` 保存；同时在 `meta_node_child_rule` 中定义各类型的合法子类型，防止出现非法层级。  
  - `depth` 与 `path` 便于批量查询某一层级；`full_name` 降低多次 JOIN 成本。

- `meta_item`  
  - 表示最底层的数据项，数据库对应 table / view，对象存储对应 object，不再允许有子节点。  
  - 关键字段：`id`、`res_id`、`node_id`、`item_type`、`attributes`（JSON 存储字段列表、文件大小、修改时间等）。  
  - JSON 字段需要记录 `meta_schema_version`，并对高频属性（如 `row_count`、`object_size`、`last_modified_at`）单独建列以便索引与过滤。  
  - 同样包含 `status`、`sync_version`、`deleted_at` 等基础字段。

为支撑增量同步与追踪：
- 所有 JSON 字段采用统一结构，并在 `meta_json_schema` 中记录版本与校验规则。
- 引入 `meta_change_log`（资源、节点、项目共享）记录采集事件、变更来源、批次号，便于审计与回溯。
- 建议每次同步写入 `last_synced_at` 与 `sync_version`，便于比对差异。

说明：迁移到上述新结构之前，需清理旧版按资源类型拆分的表（批量删除或迁移后 drop），以免干扰新的层级模型和索引策略。



meta模块前端页面包括以下内容：
## 元数据扫描
当点击左侧的“元数据扫描”时，右侧窗口，列出所有存储引擎。

### 数据库
选中一个数据库后，列出其所有schema，可以多选或者全选这些schema，然后再扫描这些schema中的所有表及其字段。
扫描后的元数据，存储到系统数据库的meta schema中，供其他模块后续使用。
除了上述手动扫描，右侧窗口还提供设置自动扫描时间的功能，默认为每晚十二点。
扫描前，对应的schema的状态为“未扫描”；扫描开始后，状态为“扫描中”；扫描结束后，状态为“已扫描”，并标明最后扫描时间。
### 对象存储
采用S3接口，兼容minio、S3、阿里oss等各类对象存储引擎；
分级列出注册范围内的bucket、prefix目录、以及当前目录下的文件；
支持同一个级别下的多选，选择后，统一进行元数据扫描；
扫描时，记录类型（桶、目录或对象），文件类型（按照文件名后缀）、大小，以及扫描时间


# manager模块
## 数据探查
列出存储引擎，按层级展开其中的schema和表（已经被meta扫描过的）
在选中一张表后，右侧用表格的方式展示前五十行记录（每页十行，分五页）
如果包括空间数据，则加载到地图上展示


# 数据支持
## 存储引擎
### Postgresql
#### meta
元数据扫描，选择schema，扫描其中的所有表和字段
#### manager
数据探查，按照扫描过的schema和表进行展示和管理；是否需要再进行目录管理，待定
### minio
支持打包后的shape文件上传
可上传小文件（xxx MB以下）
后台自动解压缩
